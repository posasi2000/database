MySQL 서버는 = MySQL 엔진 + 스토리지 엔진
  ㄴMySQL 엔진은 클라이언트로부터 오는 요청 처리(요청된 SQL 문장을 분석, 최적화, ...) 담당하고
     ㄴConnection Handler 커넥션및 쿼리요청 담당
     ㄴSQL인터페이스 DML/DDL/Procedure/View 담당
     ㄴSQL파서는 SQL문법오류탐지및 SQL쿼리문장을 처리하기 좋은 토큰단위로 나눠서 트리형태로 파싱
     ㄴSQL옵티마이저 쿼리의 최적화담당
     ㄴ캐쉬와버퍼는 성능향상을 위한 보조저장소 기능
  ㄴ스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 조회하는 부분을 담당한다.
     ㄴ스토리지엔진은 InnoDB구조로 메모리영역과 디스크영역
          ㄴ메모리영역은 데이터와 인덱스를 적재하는 innoDB버퍼풀, undo로그, insertBuffer
	  ㄴ디스크영역은 시스템/사용자테이블스페이스, redo로그 
     ㄴMySQL엔진과 플러그인형태로 연동/분리가 가능
     ㄴ핸들러API를 통해 스토리지엔진에 읽기/쓰기요청이 가능

MySQL 스레드 = foreground thread + background thread
  ㄴ백그라운드 스레드
     ㄴInsert buffer를 병합하는 스레드
     ㄴ로그 기록 스레드
     ㄴInnoDB 버퍼 풀의 데이터를 디스크로 기록(Write)하는 스레드
     ㄴ데이터를 버퍼로 읽어들이는 스레드
     ㄴ잠금, 데드락을 모니터링하는 스레드
     ㄴ모든 백그라운드 스레드를 관리하는 메인 스레드
  ㄴ foreground thread
      ㄴ클라이언트/사용자가 요청한 쿼리 문장을 처리하는 스레드(고객 창구 역할)
      ㄴ데이터 조회 스레드(데이터 버퍼나 캐시 또는 직접 디스크나 인덱스 파일로 접근하여 데이터를 가져오는 스레드)

메모리 구조 = 글로벌메모리영역 + 로컬세션메모리영역
  ㄴ글로벌메모리영역
       ㄴMySQL 서버를 실행할 때 운영체제로부터 설정한 만큼 할당받는 영역
       ㄴ모든 스레드로부터 공유되는 영역
  ㄴ로컬세션메모리영역
       ㄴ클라이언트 스레드가 쿼리를 처리하는데 쓰이는 영역
       ㄴ스레드 별로 독립적이라 절대 공유되지 않는 영역

인덱스 종류
- 클러스터형 인덱스(clustered index) - 영어사전에 비유
  	: 영어사전 처럼 정렬이 되어 있음
	자동으로 생성되는 인덱스(PK경우)
	기본키로 지정하면 클러스터형 인덱스는 자동으로 생성된다.
	테이블에 1개만 생성된다.
- 클러스터형 인덱스가 생성되면 그 열을 기준으로 자동 정렬되어
  	 검색 시 빠르게 검색 가능하다.
- 보조 인덱스(secondary index) - 책 뒤의 찾아보기와 비슷
	: unique key로 지정하면 보조 인덱스가 생성된다.
	보조 인덱스는 테이블에 여러 개 설정 가능
	보조 인덱스를 생성해도 데이터의 순서는 변경되지 않고
  	별도로 인덱스를 만든다.

index생성이유]
 -일일이 검사를 하게 되면 조회 시간이 점차 증가하게 되기 마련이다. (이것은 성능 저하이자 곧 서비스 품질 저하다.)
 -데이터를 하나하나 전부다 조건을 검사하게 되면 검색 성능이 매우 떨어지는 문제가 발생하는데 이 문제를 해결하기 위한 기술이 바로 인덱스다.
 -일반적으로 책 뒤에 "색인"처럼 어느 페이지에 어떤 단어가 있는지 
 -대략적으로 파악할 수 있는 것을 제공하는 것과 비슷하게 해결한다. (대부분의 RDMBS가 유사하게 문제를 해결했다.)
 -알파벳(a, b, c ,...)순서 또는 한글(ㄱ, ㄴ, ㄷ, ...)순서 등의 형태로 정렬되어있다.
 -용어를 직접 요약해서 설명하기보다 어느 페이지에 있는지 간단한 페이지 번호만 나타냈다.
 -책 전체는 수 백 페이지지만 색인 정보가 있는 페이지는 몇 페이지 안된다.
 -너무 여러 곳에 등장하는 용어는 색인에 나타내지 않는다.
 -조회 성능을 올리는 데는 크게 도움이 되었지만 삽입, 수정, 삭제 성능은 떨어지게 되었다.
 -왜냐하면 레코드를 추가하거나 삭제, 수정할 때는 
   생성된 인덱스에도 데이터 동기화를 해줘야 하기 때문에 오버헤드가 생기기 때문이다.
 -대부분의 RDBMS 구현체들은 기본적으로 B-TREE 인덱스를 사용한다

  alter table guest add constraint unique(sabun);
  select * from guest;


# 인덱스 확인
show index from 테이블명;

# 인덱스 생성
CREATE INDEX <인덱스명> ON <테이블명> ( 칼럼명1, 칼럼명2, ... );
create index memo_name_idx on memo (name);

# 테이블 생성시 인덱스 생성
create table 테이블명(
 컬럼명 자료형,
 ...
 index 인덱스명 (컬럼명) -- 항상 유니크해야 함
)
# 인덱스 추가
alter table member add index member_userid_idx (userid);

# 인덱스 조회
show index from 테이블명

# 인덱스 삭제
alter table 테이블명 drop index 인덱스명

*---------------------------------------------------------------------------
*튜닝할때 인덱스 예문기술
인덱스 추가]
mysql> alter table 사원  add index I_사원_성_이름 (성, 이름);
mysql> show index from 사원;   --하나추가되어서 6개
인덱스삭제는 drop
mysql>  alter table 사원  drop index I_사원_성_이름;

예외] 인덱스 없이 작은 규모의 조회하는 나쁜SQL문
mysql> show index from 사원;   --5개
mysql>
 explain 
 select *  from 사원	
 where 이름 = 'Georgi'	
 and 성 = 'Wielonsky' ;

mysql> alter table 사원  add index I_사원_성_이름 (성, 이름);
mysql> show index from 사원;   --하나추가되어서 6개


Fetch time 
 ㄴ페치된결과를 전송하는 데 결리는 시간 측정. 이는 쿼리실행과 관련이 없습니다.
Duration time
 ㄴ쿼리문실행해야 하는 시간